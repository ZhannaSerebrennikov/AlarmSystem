Creating a control panel sensor alarm system using the Observer pattern in C++ involves defining a way to notify objects (observers) when an event occurs in another object (the subject). In this case, your sensors are the subjects, and the alarm system is an observer that needs to be notified whenever there's a change in the sensor state.

Here’s a basic outline and implementation in C++:

### Components

1. **Subject Interface**: This will be the base class for the sensors. It allows observers to register and unregister themselves.
2. **Observer Interface**: This will be the base class for the alarm system and any other observer that needs to be notified about changes.
3. **Concrete Sensor**: Implements the sensor logic and notifies observers of changes.
4. **Concrete Alarm**: Implements the logic for handling sensor changes (e.g., triggering an alarm).

### Implementation

```cpp
#include <iostream>
#include <vector>
#include <string>

// Observer Interface
class Observer {
public:
    virtual void update(const std::string& message) = 0;
    virtual ~Observer() {}
};

// Subject Interface
class Subject {
public:
    virtual void addObserver(Observer* observer) = 0;
    virtual void removeObserver(Observer* observer) = 0;
    virtual void notifyObservers() = 0;
    virtual ~Subject() {}
};

// Concrete Sensor (Subject)
class Sensor : public Subject {
private:
    std::vector<Observer*> observers;
    std::string status;

public:
    void setStatus(const std::string& newStatus) {
        status = newStatus;
        notifyObservers();
    }

    std::string getStatus() const {
        return status;
    }

    void addObserver(Observer* observer) override {
        observers.push_back(observer);
    }

    void removeObserver(Observer* observer) override {
        observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
    }

    void notifyObservers() override {
        for (Observer* observer : observers) {
            observer->update(status);
        }
    }
};

// Concrete Alarm (Observer)
class Alarm : public Observer {
public:
    void update(const std::string& message) override {
        std::cout << "Alarm triggered! Sensor status: " << message << std::endl;
        // Additional alarm logic can be added here
    }
};

int main() {
    Sensor sensor1;
    Sensor sensor2;
    
    Alarm alarm;
    
    sensor1.addObserver(&alarm);
    sensor2.addObserver(&alarm);
    
    sensor1.setStatus("Motion detected");
    sensor2.setStatus("Temperature exceeded limit");
    
    // You can remove the alarm if needed
    sensor1.removeObserver(&alarm);
    sensor2.setStatus("Motion detected again");
    
    return 0;
}
```

### Explanation

1. **Observer Interface**: The `Observer` class has a pure virtual `update` method which will be overridden by concrete observers to define how they react to updates.

2. **Subject Interface**: The `Subject` class defines methods to add, remove, and notify observers. Concrete subjects will implement these methods to manage their list of observers and notify them of changes.

3. **Concrete Sensor**: The `Sensor` class implements the `Subject` interface. It holds a list of observers and notifies them when its status changes.

4. **Concrete Alarm**: The `Alarm` class implements the `Observer` interface. It reacts to sensor status changes by outputting a message. You can expand this class with more complex alarm handling logic as needed.

5. **Main Function**: Demonstrates creating sensors and an alarm, adding the alarm as an observer to the sensors, and triggering updates.

This basic setup can be extended with more sophisticated features, like handling different types of alarms or sensors, using more complex status messages, or integrating with real-world systems.